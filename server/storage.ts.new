import { 
  users, personas, personas_inmuebles, inmuebles, inmuebles_ubicaciones, ubicaciones,
  type User, type InsertUser, type Persona, type InsertPersona, 
  type Inmueble, type InsertInmueble, type Ubicacion, type InsertUbicacion
} from "@shared/schema";
import { db } from "./db";
import { eq, and, sql } from "drizzle-orm";

// Define the storage interface for the application
export interface IStorage {
  // User methods
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  
  // Relationship methods
  getInmueblesRelacionadosConPersona(personaId: number): Promise<Inmueble[]>;
  getUbicacionesRelacionadasConInmueble(inmuebleId: number): Promise<Ubicacion[]>;
  
  // Entity creation methods
  createPersona(persona: InsertPersona): Promise<Persona>;
  createInmueble(inmueble: InsertInmueble): Promise<Inmueble>;
  createUbicacion(ubicacion: InsertUbicacion): Promise<Ubicacion>;
  
  // Relationship creation methods
  crearRelacionPersonaInmueble(personaId: number, inmuebleId: number): Promise<boolean>;
  crearRelacionInmuebleUbicacion(inmuebleId: number, ubicacionId: number): Promise<boolean>;
}

// Database implementation of storage interface
export class DatabaseStorage implements IStorage {
  // User methods
  async getUser(id: number): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user || undefined;
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.email, username));
    return user || undefined;
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const [user] = await db
      .insert(users)
      .values(insertUser)
      .returning();
    return user;
  }
  
  // Entity creation methods
  async createPersona(insertPersona: InsertPersona): Promise<Persona> {
    const [persona] = await db
      .insert(personas)
      .values(insertPersona)
      .returning();
    return persona;
  }
  
  async createInmueble(insertInmueble: InsertInmueble): Promise<Inmueble> {
    const [inmueble] = await db
      .insert(inmuebles)
      .values(insertInmueble)
      .returning();
    return inmueble;
  }
  
  async createUbicacion(insertUbicacion: InsertUbicacion): Promise<Ubicacion> {
    const [ubicacion] = await db
      .insert(ubicaciones)
      .values(insertUbicacion)
      .returning();
    return ubicacion;
  }
  
  // Relationship methods
  async getInmueblesRelacionadosConPersona(personaId: number): Promise<Inmueble[]> {
    try {
      const result = await db.execute(
        sql`SELECT i.* FROM inmuebles i
            JOIN personas_inmuebles pi ON i.id = pi.inmueble_id
            WHERE pi.persona_id = ${personaId}`
      );
      
      return result.rows || [];
    } catch (error) {
      console.error(`Error al obtener inmuebles relacionados con la persona ${personaId}:`, error);
      return [];
    }
  }
  
  async getUbicacionesRelacionadasConInmueble(inmuebleId: number): Promise<Ubicacion[]> {
    try {
      const result = await db.execute(
        sql`SELECT u.* FROM ubicaciones u
            JOIN inmuebles_ubicaciones iu ON u.id = iu.ubicacion_id
            WHERE iu.inmueble_id = ${inmuebleId}`
      );
      
      return result.rows || [];
    } catch (error) {
      console.error(`Error al obtener ubicaciones relacionadas con el inmueble ${inmuebleId}:`, error);
      return [];
    }
  }
  
  // Relationship creation methods
  async crearRelacionPersonaInmueble(personaId: number, inmuebleId: number): Promise<boolean> {
    try {
      // Verificar si la relación ya existe
      const existingRelacion = await db
        .select()
        .from(personas_inmuebles)
        .where(
          and(
            eq(personas_inmuebles.personaId, personaId),
            eq(personas_inmuebles.inmuebleId, inmuebleId)
          )
        );
      
      if (existingRelacion.length > 0) {
        console.log(`La relación entre persona ${personaId} e inmueble ${inmuebleId} ya existe`);
        return true;
      }
      
      // Crear la relación
      await db
        .insert(personas_inmuebles)
        .values({
          personaId,
          inmuebleId
        });
      
      console.log(`Relación creada entre persona ${personaId} e inmueble ${inmuebleId}`);
      return true;
    } catch (error) {
      console.error(`Error al crear relación entre persona ${personaId} e inmueble ${inmuebleId}:`, error);
      return false;
    }
  }
  
  async crearRelacionInmuebleUbicacion(inmuebleId: number, ubicacionId: number): Promise<boolean> {
    try {
      // Verificar si la relación ya existe
      const existingRelacion = await db
        .select()
        .from(inmuebles_ubicaciones)
        .where(
          and(
            eq(inmuebles_ubicaciones.inmuebleId, inmuebleId),
            eq(inmuebles_ubicaciones.ubicacionId, ubicacionId)
          )
        );
      
      if (existingRelacion.length > 0) {
        console.log(`La relación entre inmueble ${inmuebleId} y ubicación ${ubicacionId} ya existe`);
        return true;
      }
      
      // Crear la relación
      await db
        .insert(inmuebles_ubicaciones)
        .values({
          inmuebleId,
          ubicacionId
        });
      
      console.log(`Relación creada entre inmueble ${inmuebleId} y ubicación ${ubicacionId}`);
      return true;
    } catch (error) {
      console.error(`Error al crear relación entre inmueble ${inmuebleId} y ubicación ${ubicacionId}:`, error);
      return false;
    }
  }
}

export const storage = new DatabaseStorage();